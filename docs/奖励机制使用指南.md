# 任务奖励机制使用指南

## 概述

本文档说明了如何使用任务管理系统中的代币奖励机制。该机制实现了以下功能：

1. **创建任务时预留奖励**：创建者的代币会被锁定
2. **任务完成时自动发放奖励**：代币转移给执行者
3. **任务取消时释放预留资金**：代币返还给创建者
4. **任务删除时的资金处理**：确保资金不会丢失

## 核心功能

### 1. 奖励预留机制

当用户创建任务时：
```rust
// 创建任务时会自动执行以下步骤：
// 1. 验证奖励金额不为零
ensure!(!reward.is_zero(), Error::<T>::InvalidReward);

// 2. 检查创建者余额是否足够
ensure!(
    T::Currency::can_reserve(&creator, reward),
    Error::<T>::InsufficientBalance
);

// 3. 预留（锁定）奖励金额
T::Currency::reserve(&creator, reward)?;
```

**特点**：
- 防止创建者在任务执行期间转移资金
- 确保任务完成时有足够资金支付奖励
- 发出 `TaskRewardReserved` 事件

### 2. 奖励发放机制

当任务状态变更为"已完成"时：
```rust
// 任务完成时自动执行：
if new_status == 2 { // Completed
    if let Some(assignee) = &task.assignee {
        // 1. 释放创建者的预留资金
        T::Currency::unreserve(&task.creator, task.reward);
        
        // 2. 转账给执行者
        T::Currency::transfer(
            &task.creator,
            assignee,
            task.reward,
            KeepAlive,
        )?;
        
        // 3. 发出奖励发放事件
        Self::deposit_event(Event::TaskRewardPaid { ... });
    }
}
```

**特点**：
- 自动化奖励发放，无需额外操作
- 确保只有已分配的任务才能获得奖励
- 发出 `TaskRewardPaid` 事件

### 3. 奖励释放机制

当任务被取消或删除时：
```rust
// 任务取消时
if new_status == 3 { // Cancelled
    T::Currency::unreserve(&task.creator, task.reward);
    Self::deposit_event(Event::TaskRewardReleased { ... });
}

// 任务删除时
if task.status != 2 && task.status != 3 { // 不是已完成或已取消
    T::Currency::unreserve(&task.creator, task.reward);
    Self::deposit_event(Event::TaskRewardReleased { ... });
}
```

**特点**：
- 确保资金不会被永久锁定
- 未完成的任务删除时自动释放资金
- 发出 `TaskRewardReleased` 事件

## 使用示例

### 创建带奖励的任务

```javascript
// 前端调用示例
const createTask = async () => {
  const extrinsic = api.tx.tasks.createTask(
    "完成用户认证功能",           // title
    "实现JWT认证和权限管理",      // description
    3,                          // priority (High)
    7,                          // difficulty
    "1000000000000",            // reward (1000 tokens)
    null                        // deadline (optional)
  );
  
  await extrinsic.signAndSend(account);
};
```

### 监听奖励事件

```javascript
// 监听奖励相关事件
api.query.system.events((events) => {
  events.forEach((record) => {
    const { event } = record;
    
    if (event.section === 'tasks') {
      switch (event.method) {
        case 'TaskRewardReserved':
          console.log('奖励已预留:', event.data);
          break;
        case 'TaskRewardPaid':
          console.log('奖励已发放:', event.data);
          break;
        case 'TaskRewardReleased':
          console.log('奖励已释放:', event.data);
          break;
      }
    }
  });
});
```

## 错误处理

### 常见错误

1. **InsufficientBalance**
   - 原因：创建者余额不足
   - 解决：检查账户余额后再创建任务

2. **InvalidReward**
   - 原因：奖励金额为零
   - 解决：设置大于零的奖励金额

3. **RewardTransferFailed**
   - 原因：转账失败（罕见）
   - 解决：检查执行者账户状态

### 错误处理示例

```javascript
try {
  await api.tx.tasks.createTask(...args).signAndSend(account);
} catch (error) {
  if (error.message.includes('InsufficientBalance')) {
    alert('余额不足，无法创建任务');
  } else if (error.message.includes('InvalidReward')) {
    alert('奖励金额必须大于零');
  }
}
```

## 最佳实践

### 1. 奖励金额设置
- 根据任务难度合理设置奖励
- 考虑网络费用，避免奖励过低
- 建议最低奖励: 10^12 (1 token)

### 2. 余额管理
- 创建任务前检查余额
- 预留足够资金用于网络费用
- 定期检查锁定资金状态

### 3. 状态管理
- 及时更新任务状态
- 避免长期保持"进行中"状态
- 合理使用"待验证"状态

## 技术实现细节

### 存储结构
```rust
// 任务结构中的奖励字段
pub struct Task<T: Config> {
    pub reward: T::Balance,    // 奖励金额
    // ... 其他字段
}
```

### 事件定义
```rust
pub enum Event<T: Config> {
    TaskRewardReserved { task_id: u32, creator: T::AccountId, reward: T::Balance },
    TaskRewardPaid { task_id: u32, assignee: T::AccountId, creator: T::AccountId, reward: T::Balance },
    TaskRewardReleased { task_id: u32, creator: T::AccountId, reward: T::Balance },
}
```

### 权限控制
- 只有任务创建者可以修改奖励
- 只有在任务完成时才能发放奖励
- 系统自动处理资金的锁定和释放

## 与声誉系统的集成

奖励机制与声誉系统紧密集成：
- 完成任务获得奖励的同时提升声誉
- 高声誉用户可能获得更多任务机会
- 奖励金额可以影响声誉增长幅度

## 总结

奖励机制确保了任务平台的经济激励：
- **安全性**：预留机制防止资金不足
- **自动化**：状态变更时自动处理奖励
- **透明性**：所有操作都有对应事件
- **公平性**：只有完成任务才能获得奖励

通过合理使用这些功能，可以构建一个公平、高效的去中心化任务管理平台。 